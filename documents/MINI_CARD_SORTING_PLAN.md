# План реализации сортировки дел в мини-карточке дня

## 1. Анализ структуры данных (ключевые моменты)

*   **Тип дела**: Определяется полем `task.type`. Для сортировки предполагается:
    *   "Доход": `Task`, у которого `type` не равен `'expense'` И есть поле `time` (например, `task.type !== 'expense' && task.time`). Ожидается уточнение от бэкенда, может ли `task.type` быть явно `'income'`.
    *   "Расход": `Task`, у которого `type` равен `'expense'`.
*   **Время дохода**: Поле `task.time` (строка, ожидаемый формат "ЧЧ:ММ").
*   **Порядок расходов**: Предполагается, что исходный порядок `tasksForDay` для расходов нужно сохранить. Если порядок не гарантирован бэкендом и важен, можно использовать `task.uuid` или `task.createdAt` для стабильной сортировки.
*   **Затрагиваемые файлы**:
    *   [`front/src/components/MiniEventCard.tsx`](front/src/components/MiniEventCard.tsx:0): Отображает отдельное дело.
    *   [`front/src/services/api.ts`](front/src/services/api.ts:0): Содержит определения типов `Task` и `Note`.
    *   [`front/src/components/DayColumn.tsx`](front/src/components/DayColumn.tsx:0): Родительский компонент, где будет реализована сортировка.

## 2. Оптимальное место для реализации логики сортировки

*   В компоненте [`front/src/components/DayColumn.tsx`](front/src/components/DayColumn.tsx:0).
*   Внутри хука `useEffect` (строки [`front/src/components/DayColumn.tsx:40-54`](front/src/components/DayColumn.tsx:40-54)), после формирования массива `taskEvents` (из пропса `tasksForDay`) и перед вызовом `setEvents`.
*   Текущий комментарий `// TODO: Добавить сортировку событий по времени (если это еще актуально только для задач)` на строке [`front/src/components/DayColumn.tsx:52`](front/src/components/DayColumn.tsx:52) указывает на предполагаемое место.

## 3. Алгоритм сортировки

```mermaid
graph TD
    A[Получить tasksForDay из props] --> B{Преобразовать в EventItem[] (taskEvents)};
    B --> C{Разделить taskEvents на "Доходы" и "Расходы"};
    C -- "Доходы" (incomeEvents) --> D{Отсортировать "Доходы" по времени (task.time, "ЧЧ:ММ") от раннего к позднему};
    C -- "Расходы" (expenseEvents) --> E[Сохранить исходный порядок "Расходов"];
    D --> F[Объединить: отсортированные "Доходы" + "Расходы" в sortedEvents];
    E --> F;
    F --> G[Вызвать setEvents(sortedEvents) для обновления UI];
```

**Детали алгоритма:**

1.  **Разделение на группы:**
    *   Создать два временных массива: `incomeEvents` и `expenseEvents`.
    *   Итерировать по массиву `taskEvents`:
        *   Если элемент определен как "доход" (например, `task.type !== 'expense' && task.time`), добавить его в `incomeEvents`.
        *   Иначе (если это "расход", например, `task.type === 'expense'`), добавить его в `expenseEvents`.
2.  **Сортировка "доходов"**:
    *   Отсортировать массив `incomeEvents` с использованием функции сравнения для поля `time`.
    *   Функция сравнения должна корректно обрабатывать строки "ЧЧ:ММ". Пример: `(a, b) => a.time!.localeCompare(b.time!)`. (Необходима проверка на существование `time`).
3.  **Сохранение порядка "расходов"**:
    *   Массив `expenseEvents` будет содержать расходы в их исходном порядке добавления. Дополнительная сортировка не требуется, если исходный порядок из `tasksForDay` стабилен и его нужно сохранить.
4.  **Объединение**:
    *   Создать итоговый отсортированный массив: `const sortedEvents = [...incomeEvents, ...expenseEvents];`.
5.  **Обновление состояния**:
    *   Вызвать `setEvents(sortedEvents)`.

## 4. Влияние на производительность

*   Сортировка выполняется на клиенте при каждом обновлении `tasksForDay`.
*   Для ожидаемого количества дел (десятки) стандартные методы сортировки JavaScript (`Array.prototype.sort`) достаточно эффективны.
*   Сложность алгоритма: O(N log N) для сортировки доходов + O(M) для разделения на группы (N - кол-во доходов, M - общее кол-во дел). Это приемлемо.
*   Дальнейшие оптимизации (мемоизация, перенос на бэкенд) на данном этапе преждевременны.

## 5. Рекомендации по реализации

*   **Место**: [`front/src/components/DayColumn.tsx`](front/src/components/DayColumn.tsx:52) в `useEffect`.
*   **Определение типа "доход/расход"**:
    *   Начать с:
        *   Доход: `task.type !== 'expense' && typeof task.time === 'string' && task.time.match(/^\d{2}:\d{2}$/)`.
        *   Расход: `task.type === 'expense'`.
    *   Быть готовым адаптировать при получении информации о `task.type === 'income'` от бэкенда.
*   **Сравнение времени**:
    *   Для строк "ЧЧ:ММ" использовать `localeCompare`. Убедиться, что поле `time` существует для всех элементов, считающихся доходами.
*   **Обработка отсутствующего времени у доходов**: По текущей логике, если у элемента, который мог бы быть доходом, нет времени, он не будет классифицирован как доход. Если такие случаи возможны и их нужно обрабатывать иначе, это требует уточнения.
*   **Стабильность сортировки расходов**: Если исходный порядок расходов важен, но не гарантирован при получении `tasksForDay`, рассмотреть использование `createdAt` или `uuid` для их стабильной (но произвольной) сортировки. Если порядок не важен, текущий подход достаточен.
*   **Тестирование**: Провести тщательное тестирование с различными наборами данных:
    *   Только доходы.
    *   Только расходы.
    *   Смешанные доходы и расходы.
    *   Доходы с одинаковым временем.
    *   Пустой список дел.
    *   Дела с некорректным/отсутствующим форматом времени (если это возможно для "доходов").
    *   Убедиться, что заметки (`Note`) не затрагиваются и не попадают в эту сортировку, так как они сейчас не включены в `events` в `DayColumn`.